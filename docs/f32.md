# Misbehaving `f32` values

Floating point values have a notorious reputation for misbehaving.

This is due to the fundamental limitation that for a particular number base (2 in this case), certain quantities cannot be represented precisely.

We are all familiar with this problem when using decimal fractions.
For instance, we know that the quantity 1/3 cannot be represented as a decimal fraction.
Writing:

* `0.3` is close
* `0.333` is closer
* `0.33333` is closer still

But no matter how many digits you include in the decimal fraction, you will never arrive at a precise definition simply because you have hit a basic limitation of the base 10 counting system.

Exactly the same limitations exist in binary.

In the same way that base 10 has no way to accurately represent 1/3 as a decimal fraction, so base 2 has no way to represent 1/10 as a binary fraction.

However, people seem to have forgotten this when working with floating point values.

## JavaScript's `Math.PI` (and Other Built-in Constants)

Run `npm run f32` to see a practical demonstration of this issue.

```bash
npm run f32

> understanding-wasm-simd-instructions@1.1.0 f32
> wat2wasm ./src/f32.wat -o ./bin/f32.wasm && node ./f32.mjs

❌ Floating point tests: f32_from_array_precise failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
✅ Floating point tests: f32_from_array_imprecise passed within acceptable floating point tolerance
✅ Floating point tests: f64_from_array passed
❌ Floating point tests: f32_wasm_echo_precise failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
✅ Floating point tests: f32_wasm_echo_imprecise passed
❌ Floating point tests: f32_wasm_hardcoded failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
❌ Floating point tests: f32_from_shared_memory failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
✅ Floating point tests: f32_from_shared_memory passed
```

The value returned from JavaScript's `Math.PI` cannot infact be represented ***as quoted*** in a single precision floating point number.

In the same way that `0.1` has no exact representation as a binary fraction, so the value returned by `Math.PI` cannot be represented precisely as a single-precision floating point value.

```
                       Math.PI = 3.141592653589793
    new F32Array([Math.PI])[0] = 3.1415927410125732
Differs in the 7th decimal place --------^
```

This [float converter](https://www.h-schmidt.net/FloatConverter/IEEE754.html) web page nicely illustrates the problem.
Paste the value of `Math.PI` (`3.141592653589793`) into the "You entered" field and see the discrepancy for yourself at the binary level.

## What Does This Have To Do With WebAssembly

Strictly speaking: nothing.

You will encounter this problem in JavaScript withpout needing to go anywhere near WebAssembly; however, anytime floating point values pass between WebAssembly and a JavaScript host, you may experience an alteration of the value.

This has nothing to do with WebAssembly itself, but instead is related to the way floating point numbers are encoded in 32 bits.
If this turns out to be a problem for you, you should use 64-bit floating point numbers, which are less prone to this type of problem.

Hence, some tests pass with the message `passed within acceptable floating point tolerance`.
