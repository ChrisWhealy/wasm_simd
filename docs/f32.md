# Misbehaving `f32` values

Floating point values have a notorious reputation for misbehaving.

This is due to the fundamental limitation that for a particular number base (2 in this case), certain quantities cannot be represented precisely.

We are all familiar with this problem when using decimal fractions.
For instance, we know that the quantity 1/3 has no precise representation as a decimal fraction.
Writing:

* `0.3` is close
* `0.333` is closer
* `0.33333` is closer still

But no matter how many digits you include in the decimal fraction, you will never arrive at the precise quantity simply because you have hit a basic limitation of the base 10 counting system.

Exactly the same limitations exist in binary.

In the same way that base 10 has no way to accurately represent 1/3 as a decimal fraction, so base 2 has no way to represent 1/10 as a binary fraction.

However, people seem to have forgotten this when working with floating point values.

## JavaScript's `Math.PI` (and Other Built-in Constants)

Run `npm run f32` to see a practical demonstration of this issue.

```bash
npm run f32

> understanding-wasm-simd-instructions@1.1.0 f32
> wat2wasm ./src/f32.wat -o ./bin/f32.wasm && node ./f32.mjs

❌ Floating point tests: f32_from_array_precise failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
✅ Floating point tests: f32_from_array_imprecise passed within acceptable floating point tolerance
✅ Floating point tests: f64_from_array passed
❌ Floating point tests: f32_wasm_echo_precise failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
✅ Floating point tests: f32_wasm_echo_imprecise passed
❌ Floating point tests: f32_wasm_hardcoded failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
❌ Floating point tests: f32_from_shared_memory failed
               Expected: 3.141592653589793
               Received: 3.1415927410125732
             Difference: 0.00000008742278012618954
✅ Floating point tests: f32_from_shared_memory passed
```

In the same way that `0.1` has no exact representation as a binary fraction, so the value returned by `Math.PI` cannot be represented ***as quoted*** in a single precision floating point number.

```
                       Math.PI = 3.141592653589793
    new F32Array([Math.PI])[0] = 3.1415927410125732
Differs in the 7th decimal place --------^
```

This [float converter](https://www.h-schmidt.net/FloatConverter/IEEE754.html) web page nicely illustrates the problem.
Paste the value of `Math.PI` (`3.141592653589793`) into the "You entered" field and see the discrepancy for yourself at the binary level.

## What Does This Have To Do With WebAssembly

Strictly speaking: nothing, since you will encounter this problem in JavaScript without needing to go anywhere near WebAssembly.
That said, anytime floating point values pass between WebAssembly and a JavaScript host, you may experience an alteration of the value.

If this turns out to be a problem, then you should switch to using 64-bit floating point numbers, which still have their issues, but the discrepancies tend to be much smaller.

This is why you will see some tests pass with the message `passed within acceptable floating point tolerance`.
